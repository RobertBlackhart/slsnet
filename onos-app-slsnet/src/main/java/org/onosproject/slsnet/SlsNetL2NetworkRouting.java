/*
 * Copyright 2017-present Open Networking Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.onosproject.slsnet;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import org.apache.felix.scr.annotations.Activate;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Deactivate;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.ReferenceCardinality;
import org.onlab.packet.MacAddress;
import org.onlab.packet.VlanId;
import org.onlab.util.Tools;
import org.onosproject.core.ApplicationId;
import org.onosproject.core.CoreService;
import org.onosproject.incubator.net.intf.Interface;
import org.onosproject.net.ConnectPoint;
import org.onosproject.net.EncapsulationType;
import org.onosproject.net.FilteredConnectPoint;
import org.onosproject.net.Host;
import org.onosproject.net.ResourceGroup;
import org.onosproject.net.flow.DefaultTrafficSelector;
import org.onosproject.net.flow.TrafficSelector;
import org.onosproject.net.host.HostService;
import org.onosproject.net.intent.ConnectivityIntent;
import org.onosproject.net.intent.Constraint;
import org.onosproject.net.intent.Intent;
import org.onosproject.net.intent.IntentEvent;
import org.onosproject.net.intent.IntentException;
import org.onosproject.net.intent.IntentListener;
import org.onosproject.net.intent.IntentService;
import org.onosproject.net.intent.IntentUtils;
import org.onosproject.net.intent.Key;
import org.onosproject.net.intent.MultiPointToSinglePointIntent;
import org.onosproject.net.intent.SinglePointToMultiPointIntent;
import org.onosproject.net.intent.constraint.EncapsulationConstraint;
import org.onosproject.net.intent.constraint.PartialFailureConstraint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Set;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.onlab.util.Tools.groupedThreads;


/**
 * An implementation of L2NetworkOperationService.
 * Handles the execution order of the L2 Network operations generated by the
 * application.
 */
@Component(immediate = true, enabled = false)
public class SlsNetL2NetworkRouting {

    private static final int COMPLETE_TIMEOUT_SEC = 5;

    public static final String PREFIX_BROADCAST = "brc";
    public static final String PREFIX_UNICAST = "uni";
    private static final String SEPARATOR = "-";

    private final Logger log = LoggerFactory.getLogger(getClass());
    protected ApplicationId l2NetAppId;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected CoreService coreService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected IntentService intentService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected HostService hostService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected SlsNetService slsnet;

    public static final ImmutableList<Constraint> PARTIAL_FAILURE_CONSTRAINT =
            ImmutableList.of(new PartialFailureConstraint());

    protected ScheduledExecutorService schedulerExecutor;

    @Activate
    public void activate() {
        l2NetAppId = coreService.registerApplication(slsnet.L2NETWORK_APP_ID);
        log.info("slsnet l2network routing starting with l2net app id {}", l2NetAppId.toString());

        // A single thread pool for L2NetworkOperationScheduler
        schedulerExecutor = Executors.newScheduledThreadPool(1,
                                            groupedThreads("onos/apps/slsnet", "scheduler-%d", log));
        // Start the scheduler
        schedulerExecutor.scheduleAtFixedRate(new L2NetworkUpdate(),
                                            0, 500, TimeUnit.MILLISECONDS);

        log.info("slsnet l2network started");
    }

    @Deactivate
    public void deactivate() {
        log.info("slsnet l2network routing stopping");

        schedulerExecutor.shutdown();

        for (Intent intent : intentService.getIntents()) {
            if (intent.appId().equals(l2NetAppId)) {
                intentService.withdraw(intent);
            }
        }
        for (Intent intent : intentService.getIntents()) {
            if (intent.appId().equals(l2NetAppId)) {
                intentService.purge(intent);
            }
        }

        log.info("slsnet l2network routing stopped");
    }

    /**
     * Scheduler for L2Network Refresh operation.
     */
    class L2NetworkUpdate implements Runnable {

        @Override
        public void run() {
            for (L2Network l2Network : slsnet.getL2Networks()) {
                if (l2Network.dirty()) {
                    log.info("slsnet l2network routing update for dirty flag: {}", l2Network.name());
                    l2Network.setDirty(false);
                    updateL2NetworkIntents(l2Network);
                }
            }
            // TODO: MAY NEED TO DO REMOVES FIRST AND DO INSTALLS NEXT FOR ALL L2NETWORK INTENTS
        }

        /**
         * Updates Intents of the L2Networks.
         */
        private void updateL2NetworkIntents(L2Network l2Network) {
            // check which part we need to update
            // if we update host only, we don't need to reinstall
            // every Intents
            Set<Intent> intentsToInstall = Sets.newHashSet();
            Set<Intent> intentsToUninstall = Sets.newHashSet();
            Set<Intent> currentIntents = getCurrentIntents(l2Network);

            // Compares broadcast Intents
            Set<Intent> currentBrcIntents = currentIntents.stream()
                    .filter(intent -> intent instanceof SinglePointToMultiPointIntent)
                    .collect(Collectors.toSet());
            Set<Intent> targetBrcIntents = buildBrcIntents(l2Network, l2NetAppId);
            if (!intentSetEquals(currentBrcIntents, targetBrcIntents)) {
                // If broadcast Intents changes, it means some network
                // interfaces or encapsulation constraint changed; Need to
                // reinstall all intents
                log.info("slsnet l2network routing reinistall all intents");
                removeL2NetworkIntents(l2Network);
                installL2NetworkIntents(l2Network);
                return;
            }
           log.info("slsnet l2network routing update intents");

            // Compares unicast Intents
            Set<Intent> currentUniIntents = currentIntents.stream()
                    .filter(intent -> intent instanceof MultiPointToSinglePointIntent)
                    .collect(Collectors.toSet());
            Set<Intent> targetUniIntents = buildUniIntents(l2Network, hostsFromL2Network(l2Network), l2NetAppId);

            // New unicast Intents to install
            targetUniIntents.forEach(intent -> {
                if (!currentUniIntents.contains(intent)) {
                    intentsToInstall.add(intent);
                }
            });

            // Old unicast Intents to remove
            currentUniIntents.forEach(intent -> {
                if (!targetUniIntents.contains(intent)) {
                    intentsToUninstall.add(intent);
                }
            });
            applyIntentsRemoveSync(intentsToUninstall);
            applyIntentsAddSync(intentsToInstall);
        }

        private Set<Host> hostsFromL2Network(L2Network l2Network) {
            Set<Interface> interfaces = l2Network.interfaces();
            return interfaces.stream()
                    .map(this::hostsFromInterface)
                    .flatMap(Collection::stream)
                    .collect(Collectors.toSet());
        }

        private Set<Host> hostsFromInterface(Interface iface) {
            return hostService.getConnectedHosts(iface.connectPoint())
                    .stream()
                    .filter(host -> host.vlan().equals(iface.vlan()))
                    .collect(Collectors.toSet());
        }

        /**
         * Applies Intents synchronously with a specific direction.
         *
         * @param intents the Intents
         * @param direction the direction
         */
        private void applyIntentsAddSync(Set<Intent> intents) {
            Set<Key> pendingIntentKeys = intents.stream()
                    .map(Intent::key).collect(Collectors.toSet());
            IntentCompleter completer;
            completer = new IntentCompleter(pendingIntentKeys, IntentEvent.Type.INSTALLED);
            intentService.addListener(completer);
            intents.forEach(intentService::submit);
            try {
                // Wait until Intent operation completed
                completer.complete();
            } catch (Exception e) {
                log.error("slsnet applyIntentsRemoveSync error: {}", e);
            } finally {
                intentService.removeListener(completer);
            }
        }
        private void applyIntentsRemoveSync(Set<Intent> intents) {
            Set<Key> pendingIntentKeys = intents.stream()
                    .map(Intent::key).collect(Collectors.toSet());
            IntentCompleter completer;
            completer = new IntentCompleter(pendingIntentKeys, IntentEvent.Type.WITHDRAWN);
            intentService.addListener(completer);
            intents.forEach(intentService::withdraw);
            try {
                // Wait until Intent operation completed
                completer.complete();
            } catch (Exception e) {
                log.error("slsnet applyIntentsRemoveSync error: {}", e);
            } finally {
                intentService.removeListener(completer);
            }
        }

        /**
         * Checks if two sets of Intents are equal.
         *
         * @param intentSet1 the first set of Intents
         * @param intentSet2 the second set of Intents
         * @return true if both set of Intents are equal; otherwise false
         */
        private boolean intentSetEquals(Set<Intent> intentSet1, Set<Intent> intentSet2) {
            if (intentSet1.size() != intentSet2.size()) {
                return false;
            }
            for (Intent intent1 : intentSet1) {
                if (intentSet2.stream()
                        .noneMatch(intent2 -> IntentUtils.intentsAreEqual(intent1, intent2))) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Retrieves installed Intents from IntentService which related to
         * specific L2 Network.
         *
         * @return the Intents which related to the L2 Network
         */
        private Set<Intent> getCurrentIntents(L2Network l2Network) {
            String l2NetworkName = l2Network.name();
            return Tools.stream(intentService.getIntents())
                    .filter(intent -> intent.key().toString().startsWith(l2NetworkName))
                    .collect(Collectors.toSet());
        }

        /**
         * Generates unicast Intents and broadcast Intents for the L2 Network.
         *
         * @return Intents for the L2 Network
         */
        private Set<Intent> generateL2NetworkIntents(L2Network l2Network) {
            Set<Intent> brcIntents = buildBrcIntents(l2Network, l2NetAppId);
            Set<Intent> uniIntent = buildUniIntents(l2Network, hostsFromL2Network(l2Network), l2NetAppId);

            return Stream.concat(brcIntents.stream(), uniIntent.stream())
                    .collect(Collectors.toSet());
        }

        /**
         * Removes all Intents from the L2 Network.
         */
        private void removeL2NetworkIntents(L2Network l2Network) {
            Set<Intent> intentsToWithdraw = getCurrentIntents(l2Network);
            applyIntentsRemoveSync(intentsToWithdraw);
            intentsToWithdraw.forEach(intentService::purge);
        }

        /**
         * Installs Intents of the L2 Network.
         */
        private void installL2NetworkIntents(L2Network l2Network) {
            Set<Intent> intentsToInstall = generateL2NetworkIntents(l2Network);
            applyIntentsAddSync(intentsToInstall);
        }


    /**
     * Builds broadcast Intents for a L2 Network.
     *
     * @param l2Network the L2 Network
     * @param appId the application id for Intents
     * @return broadcast Intents for the L2 Network
     */
    private Set<Intent> buildBrcIntents(L2Network l2Network, ApplicationId appId) {
        Set<Interface> interfaces = l2Network.interfaces();
        if (!l2Network.l2Forwarding() || interfaces.size() < 2) {
            return ImmutableSet.of();
        }
        Set<Intent> brcIntents = Sets.newHashSet();
        ResourceGroup resourceGroup = ResourceGroup.of(l2Network.name());

        // Generates broadcast Intents from any network interface to other
        // network interface from the L2 Network.
        interfaces.forEach(src -> {
            FilteredConnectPoint srcFcp = buildFilteredConnectedPoint(src);
            Set<FilteredConnectPoint> dstFcps = interfaces.stream()
                    .filter(iface -> !iface.equals(src))
                    .map(this::buildFilteredConnectedPoint)
                    .collect(Collectors.toSet());
            Key key = buildKey(PREFIX_BROADCAST, srcFcp.connectPoint(), l2Network.name(),
                               MacAddress.BROADCAST, appId);
            TrafficSelector selector = DefaultTrafficSelector.builder()
                    .matchEthDst(MacAddress.BROADCAST)
                    .build();
            SinglePointToMultiPointIntent.Builder intentBuilder = SinglePointToMultiPointIntent.builder()
                    .appId(appId)
                    .key(key)
                    .selector(selector)
                    .filteredIngressPoint(srcFcp)
                    .filteredEgressPoints(dstFcps)
                    .constraints(PARTIAL_FAILURE_CONSTRAINT)
                    .priority(SlsNetService.PRI_L2NETWORK_BROADCAST)
                    .resourceGroup(resourceGroup);
            setEncap(intentBuilder, PARTIAL_FAILURE_CONSTRAINT, l2Network.encapsulationType());
            brcIntents.add(intentBuilder.build());
        });
        return brcIntents;
    }

    /**
     * Builds unicast Intents for a L2 Network.
     *
     * @param l2Network the L2 Network
     * @param hosts the hosts of the L2 Network
     * @param appId application ID for Intents
     * @return unicast Intents for the L2 Network
     */
    private Set<Intent> buildUniIntents(L2Network l2Network, Set<Host> hosts, ApplicationId appId) {
        Set<Interface> interfaces = l2Network.interfaces();
        if (!l2Network.l2Forwarding() || interfaces.size() < 2) {
            return ImmutableSet.of();
        }
        Set<Intent> uniIntents = Sets.newHashSet();
        ResourceGroup resourceGroup = ResourceGroup.of(l2Network.name());
        hosts.forEach(host -> {
            FilteredConnectPoint hostFcp = buildFilteredConnectedPoint(host);
            Set<FilteredConnectPoint> srcFcps = interfaces.stream()
                    .map(this::buildFilteredConnectedPoint)
                    .filter(fcp -> !fcp.equals(hostFcp))
                    .collect(Collectors.toSet());
            Key key = buildKey(PREFIX_UNICAST, hostFcp.connectPoint(), l2Network.name(), host.mac(), appId);
            TrafficSelector selector = DefaultTrafficSelector.builder()
                    .matchEthDst(host.mac()).build();
            MultiPointToSinglePointIntent.Builder intentBuilder = MultiPointToSinglePointIntent.builder()
                    .appId(appId)
                    .key(key)
                    .selector(selector)
                    .filteredIngressPoints(srcFcps)
                    .filteredEgressPoint(hostFcp)
                    .constraints(PARTIAL_FAILURE_CONSTRAINT)
                    .priority(SlsNetService.PRI_L2NETWORK_UNICAST)
                    .resourceGroup(resourceGroup);
            setEncap(intentBuilder, PARTIAL_FAILURE_CONSTRAINT, l2Network.encapsulationType());
            uniIntents.add(intentBuilder.build());
        });

        return uniIntents;
    }

    /**
     * Builds an intent key either for single-point to multi-point or
     * multi-point to single-point intents, based on a prefix that defines
     * the type of intent, the single connect point representing the single
     * source or destination for that intent, the name of the L2Network the intent
     * belongs to, and the destination host MAC address the intent reaches.
     *
     * @param prefix the key prefix
     * @param cPoint the connect point identifying the source/destination
     * @param l2NetworkName the name of the L2 Network
     * @param hostMac the source/destination MAC address
     * @param appId application ID for the key
     * @return the key to identify the intent
     */
    private Key buildKey(String prefix, ConnectPoint cPoint, String l2NetworkName,
                         MacAddress hostMac, ApplicationId appId) {
        return Key.of(l2NetworkName + SEPARATOR + prefix + SEPARATOR
                          + cPoint.deviceId() + SEPARATOR + cPoint.port() + SEPARATOR + hostMac,
                      appId);
    }

    /**
     * Sets one or more encapsulation constraints on the intent builder given.
     */
    private void setEncap(ConnectivityIntent.Builder builder,
                                 List<Constraint> constraints, EncapsulationType encap) {
        // Constraints might be an immutable list, so a new modifiable list is created
        List<Constraint> newConstraints = new ArrayList<>(constraints);
        constraints.stream()
                .filter(c -> c instanceof EncapsulationConstraint)
                .forEach(newConstraints::remove);
        if (!encap.equals(EncapsulationType.NONE)) {
            newConstraints.add(new EncapsulationConstraint(encap));
        }
        // Submit new constraint list as immutable list
        builder.constraints(ImmutableList.copyOf(newConstraints));
    }

    /**
     * Builds filtered connected point by a given network interface.
     */
   private FilteredConnectPoint buildFilteredConnectedPoint(Interface iface) {
        Objects.requireNonNull(iface);
        TrafficSelector.Builder trafficSelector = DefaultTrafficSelector.builder();

        if (iface.vlan() != null && !iface.vlan().equals(VlanId.NONE)) {
            trafficSelector.matchVlanId(iface.vlan());
        }

        return new FilteredConnectPoint(iface.connectPoint(), trafficSelector.build());
    }

    /**
     * Builds filtered connected point by a given host.
     *
     * @param host the host
     * @return the filtered connected point of the given host
     */
    protected FilteredConnectPoint buildFilteredConnectedPoint(Host host) {
        Objects.requireNonNull(host);
        TrafficSelector.Builder trafficSelector = DefaultTrafficSelector.builder();

        if (host.vlan() != null && !host.vlan().equals(VlanId.NONE)) {
            trafficSelector.matchVlanId(host.vlan());
        }
        return new FilteredConnectPoint(host.location(), trafficSelector.build());
    }



        /**
         * Helper class which monitors if all Intent operations are completed.
         */
        class IntentCompleter implements IntentListener {
            private static final String INTENT_COMPILE_ERR = "Got {} from intent completer";
            private CompletableFuture<Void> completableFuture;
            private Set<Key> pendingIntentKeys;
            private IntentEvent.Type expectedEventType;

            /**
             * Initialize completer with given Intent keys and expect Intent
             * event type.
             *
             * @param pendingIntentKeys the Intent keys to wait
             * @param expectedEventType expect Intent event type
             */
            public IntentCompleter(Set<Key> pendingIntentKeys,
                                   IntentEvent.Type expectedEventType) {
                this.completableFuture = new CompletableFuture<>();
                this.pendingIntentKeys = Sets.newConcurrentHashSet(pendingIntentKeys);
                this.expectedEventType = expectedEventType;
            }

            @Override
            public void event(IntentEvent event) {
                Intent intent = event.subject();
                Key key = intent.key();
                if (!pendingIntentKeys.contains(key)) {
                    // ignore Intent events from other L2 Network
                    return;
                }
                // Intent failed, throw an exception to completable future
                if (event.type() == IntentEvent.Type.CORRUPT ||
                        event.type() == IntentEvent.Type.FAILED) {
                    completableFuture.completeExceptionally(new IntentException(intent.toString()));
                    return;
                }
                // If event type matched to expected type, remove from pending
                if (event.type() == expectedEventType) {
                    pendingIntentKeys.remove(key);
                }
                if (pendingIntentKeys.isEmpty()) {
                    completableFuture.complete(null);
                }
            }

            /**
             * Waits until all pending Intents completed ot timeout.
             */
            public void complete() {
                // If no pending Intent keys, complete directly
                if (pendingIntentKeys.isEmpty()) {
                    return;
                }
                try {
                    completableFuture.get(COMPLETE_TIMEOUT_SEC, TimeUnit.SECONDS);
                } catch (TimeoutException | InterruptedException |
                         ExecutionException | IntentException e) {
                    log.warn(INTENT_COMPILE_ERR, e.toString());
                }
            }
        }
    }

}
