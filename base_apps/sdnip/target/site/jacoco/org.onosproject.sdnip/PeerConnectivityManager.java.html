<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ko"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PeerConnectivityManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">onos-app-slsnet-sdnip</a> &gt; <a href="index.source.html" class="el_package">org.onosproject.sdnip</a> &gt; <span class="el_source">PeerConnectivityManager.java</span></div><h1>PeerConnectivityManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014-present Open Networking Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.onosproject.sdnip;

import com.google.common.collect.ImmutableList;
import org.onlab.packet.Ethernet;
import org.onlab.packet.IPv4;
import org.onlab.packet.IPv6;
import org.onlab.packet.IpAddress;
import org.onlab.packet.IpPrefix;
import org.onlab.packet.TpPort;
import org.onlab.packet.VlanId;
import org.onosproject.core.ApplicationId;
import org.onosproject.incubator.net.intf.Interface;
import org.onosproject.incubator.net.intf.InterfaceEvent;
import org.onosproject.incubator.net.intf.InterfaceListener;
import org.onosproject.incubator.net.intf.InterfaceService;
import org.onosproject.net.ConnectPoint;
import org.onosproject.net.EncapsulationType;
import org.onosproject.net.FilteredConnectPoint;
import org.onosproject.net.config.NetworkConfigEvent;
import org.onosproject.net.config.NetworkConfigListener;
import org.onosproject.net.config.NetworkConfigService;
import org.onosproject.net.flow.DefaultTrafficSelector;
import org.onosproject.net.flow.DefaultTrafficTreatment;
import org.onosproject.net.flow.TrafficSelector;
import org.onosproject.net.flow.TrafficTreatment;
import org.onosproject.net.host.InterfaceIpAddress;
import org.onosproject.net.intent.ConnectivityIntent;
import org.onosproject.net.intent.IntentUtils;
import org.onosproject.net.intent.Key;
import org.onosproject.net.intent.PointToPointIntent;
import org.onosproject.net.intent.constraint.EncapsulationConstraint;
import org.onosproject.intentsync.IntentSynchronizationService;
import org.onosproject.routing.RoutingService;
import org.onosproject.routing.config.BgpConfig;
import org.onosproject.sdnip.config.SdnIpConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.onosproject.net.EncapsulationType.NONE;

/**
 * Manages the connectivity requirements between peers.
 */
public class PeerConnectivityManager {
    private static final int PRIORITY_OFFSET = 1000;

    private static final String SUFFIX_DST = &quot;dst&quot;;
    private static final String SUFFIX_SRC = &quot;src&quot;;
    private static final String SUFFIX_ICMP = &quot;icmp&quot;;

<span class="fc" id="L75">    private static final Logger log = LoggerFactory.getLogger(</span>
            PeerConnectivityManager.class);

    private static final short BGP_PORT = 179;

    private final IntentSynchronizationService intentSynchronizer;
    private final NetworkConfigService configService;
    private final InterfaceService interfaceService;

    private final ApplicationId appId;
    private final ApplicationId routerAppId;

    private final Map&lt;Key, PointToPointIntent&gt; peerIntents;

<span class="fc" id="L89">    private final InternalNetworkConfigListener configListener</span>
            = new InternalNetworkConfigListener();

<span class="fc" id="L92">    private final InternalInterfaceListener interfaceListener</span>
            = new InternalInterfaceListener();

    /**
     * Creates a new PeerConnectivityManager.
     *
     * @param appId              the application ID
     * @param intentSynchronizer the intent synchronizer
     * @param configService      the network config service
     * @param routerAppId        application ID
     * @param interfaceService   the interface service
     */
    public PeerConnectivityManager(ApplicationId appId,
                                   IntentSynchronizationService intentSynchronizer,
                                   NetworkConfigService configService,
                                   ApplicationId routerAppId,
<span class="fc" id="L108">                                   InterfaceService interfaceService) {</span>
<span class="fc" id="L109">        this.appId = appId;</span>
<span class="fc" id="L110">        this.intentSynchronizer = intentSynchronizer;</span>
<span class="fc" id="L111">        this.configService = configService;</span>
<span class="fc" id="L112">        this.routerAppId = routerAppId;</span>
<span class="fc" id="L113">        this.interfaceService = interfaceService;</span>

<span class="fc" id="L115">        peerIntents = new HashMap&lt;&gt;();</span>
<span class="fc" id="L116">    }</span>

    /**
     * Starts the peer connectivity manager.
     */
    public void start() {
<span class="fc" id="L122">        configService.addListener(configListener);</span>
<span class="fc" id="L123">        interfaceService.addListener(interfaceListener);</span>
<span class="fc" id="L124">        setUpConnectivity();</span>
<span class="fc" id="L125">    }</span>

    /**
     * Stops the peer connectivity manager.
     */
    public void stop() {
<span class="nc" id="L131">        configService.removeListener(configListener);</span>
<span class="nc" id="L132">        interfaceService.removeListener(interfaceListener);</span>
<span class="nc" id="L133">    }</span>

    /**
     * Sets up paths to establish connectivity between all internal
     * BGP speakers and external BGP peers.
     */
    private void setUpConnectivity() {
<span class="fc" id="L140">        BgpConfig bgpConfig = configService.getConfig(routerAppId, RoutingService.CONFIG_CLASS);</span>
<span class="fc" id="L141">        SdnIpConfig sdnIpConfig = configService.getConfig(appId, SdnIpConfig.class);</span>

        Set&lt;BgpConfig.BgpSpeakerConfig&gt; bgpSpeakers;
        EncapsulationType encap;

<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if (bgpConfig == null) {</span>
<span class="nc" id="L147">            log.debug(&quot;No BGP config available&quot;);</span>
<span class="nc" id="L148">            bgpSpeakers = Collections.emptySet();</span>
        } else {
<span class="fc" id="L150">            bgpSpeakers = bgpConfig.bgpSpeakers();</span>
        }

<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        if (sdnIpConfig == null) {</span>
<span class="nc" id="L154">            log.debug(&quot;No SDN-IP config available&quot;);</span>
<span class="nc" id="L155">            encap = EncapsulationType.NONE;</span>
        } else {
<span class="fc" id="L157">            encap = sdnIpConfig.encap();</span>
        }

<span class="fc" id="L160">        Map&lt;Key, PointToPointIntent&gt; existingIntents = new HashMap&lt;&gt;(peerIntents);</span>

<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (BgpConfig.BgpSpeakerConfig bgpSpeaker : bgpSpeakers) {</span>
<span class="fc" id="L163">            log.debug(&quot;Start to set up BGP paths for BGP speaker: {}&quot;,</span>
                    bgpSpeaker);

<span class="fc" id="L166">            buildSpeakerIntents(bgpSpeaker, encap).forEach(i -&gt; {</span>
<span class="fc" id="L167">                PointToPointIntent intent = existingIntents.remove(i.key());</span>
<span class="pc bpc" id="L168" title="3 of 4 branches missed.">                if (intent == null || !IntentUtils.intentsAreEqual(i, intent)) {</span>
<span class="fc" id="L169">                    peerIntents.put(i.key(), i);</span>
<span class="fc" id="L170">                    intentSynchronizer.submit(i);</span>
                }
<span class="fc" id="L172">            });</span>
<span class="fc" id="L173">        }</span>

        // Remove any remaining intents that we used to have that we don't need
        // anymore
<span class="fc" id="L177">        existingIntents.values().forEach(i -&gt; {</span>
<span class="nc" id="L178">            peerIntents.remove(i.key());</span>
<span class="nc" id="L179">            intentSynchronizer.withdraw(i);</span>
<span class="nc" id="L180">        });</span>
<span class="fc" id="L181">    }</span>

    private Collection&lt;PointToPointIntent&gt; buildSpeakerIntents(BgpConfig.BgpSpeakerConfig speaker,
                                                               EncapsulationType encap) {
<span class="fc" id="L185">        List&lt;PointToPointIntent&gt; intents = new ArrayList&lt;&gt;();</span>

        // Get the BGP Speaker VLAN Id
<span class="fc" id="L188">        VlanId bgpSpeakerVlanId = speaker.vlan();</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">        for (IpAddress peerAddress : speaker.peers()) {</span>
<span class="fc" id="L191">            Interface peeringInterface = interfaceService.getMatchingInterface(peerAddress);</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">            if (peeringInterface == null) {</span>
<span class="fc" id="L194">                log.debug(&quot;No peering interface found for peer {} on speaker {}&quot;,</span>
                        peerAddress, speaker);
<span class="fc" id="L196">                continue;</span>
            }

<span class="fc" id="L199">            IpAddress bgpSpeakerAddress = null;</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            for (InterfaceIpAddress address : peeringInterface.ipAddressesList()) {</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">                if (address.subnetAddress().contains(peerAddress)) {</span>
<span class="fc" id="L202">                    bgpSpeakerAddress = address.ipAddress();</span>
<span class="fc" id="L203">                    break;</span>
                }
<span class="nc" id="L205">            }</span>

<span class="fc" id="L207">            checkNotNull(bgpSpeakerAddress);</span>

<span class="fc" id="L209">            VlanId peerVlanId = peeringInterface.vlan();</span>

<span class="fc" id="L211">            intents.addAll(buildIntents(speaker.connectPoint(), bgpSpeakerVlanId,</span>
                                        bgpSpeakerAddress,
<span class="fc" id="L213">                                        peeringInterface.connectPoint(),</span>
                                        peerVlanId,
                                        peerAddress,
                                        encap));
<span class="fc" id="L217">        }</span>

<span class="fc" id="L219">        return intents;</span>
    }

    /**
     * Builds the required intents between a BGP speaker and an external router.
     *
     * @param portOne the BGP speaker connect point
     * @param vlanOne the BGP speaker VLAN
     * @param ipOne the BGP speaker IP address
     * @param portTwo the external BGP peer connect point
     * @param vlanTwo the external BGP peer VLAN
     * @param ipTwo the external BGP peer IP address
     * @param encap the encapsulation type
     * @return the intents to install
     */
    private Collection&lt;PointToPointIntent&gt; buildIntents(ConnectPoint portOne,
                                                        VlanId vlanOne,
                                                        IpAddress ipOne,
                                                        ConnectPoint portTwo,
                                                        VlanId vlanTwo,
                                                        IpAddress ipTwo,
                                                        EncapsulationType encap) {

<span class="fc" id="L242">        List&lt;PointToPointIntent&gt; intents = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L244">        TrafficTreatment.Builder treatmentToPeer = DefaultTrafficTreatment.builder();</span>
<span class="fc" id="L245">        TrafficTreatment.Builder treatmentToSpeaker = DefaultTrafficTreatment.builder();</span>

        PointToPointIntent.Builder intentBuilder;

        TrafficSelector selector;
        Key key;

        byte tcpProtocol;
        byte icmpProtocol;

<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (ipOne.isIp4()) {</span>
<span class="fc" id="L256">            tcpProtocol = IPv4.PROTOCOL_TCP;</span>
<span class="fc" id="L257">            icmpProtocol = IPv4.PROTOCOL_ICMP;</span>
        } else {
<span class="nc" id="L259">            tcpProtocol = IPv6.PROTOCOL_TCP;</span>
<span class="nc" id="L260">            icmpProtocol = IPv6.PROTOCOL_ICMP6;</span>
        }

        // Add VLAN treatment for traffic going from BGP speaker to BGP peer
<span class="fc" id="L264">        treatmentToPeer = applyVlanTreatment(vlanOne, vlanTwo, treatmentToPeer);</span>

        // Path from BGP speaker to BGP peer matching destination TCP port 179
<span class="fc" id="L267">        selector = buildSelector(tcpProtocol,</span>
                vlanOne,
                ipOne,
                ipTwo,
                null,
<span class="fc" id="L272">                BGP_PORT);</span>

<span class="fc" id="L274">        key = buildKey(ipOne, ipTwo, SUFFIX_DST);</span>

<span class="fc" id="L276">        intentBuilder = PointToPointIntent.builder()</span>
<span class="fc" id="L277">                .appId(appId)</span>
<span class="fc" id="L278">                .key(key)</span>
<span class="fc" id="L279">                .filteredIngressPoint(new FilteredConnectPoint(portOne))</span>
<span class="fc" id="L280">                .filteredEgressPoint(new FilteredConnectPoint(portTwo))</span>
<span class="fc" id="L281">                .selector(selector)</span>
<span class="fc" id="L282">                .treatment(treatmentToPeer.build())</span>
<span class="fc" id="L283">                .priority(PRIORITY_OFFSET);</span>

<span class="fc" id="L285">        encap(intentBuilder, encap);</span>

<span class="fc" id="L287">        intents.add(intentBuilder.build());</span>

        // Path from BGP speaker to BGP peer matching source TCP port 179
<span class="fc" id="L290">        selector = buildSelector(tcpProtocol,</span>
                vlanOne,
                ipOne,
                ipTwo,
<span class="fc" id="L294">                BGP_PORT,</span>
                null);

<span class="fc" id="L297">        key = buildKey(ipOne, ipTwo, SUFFIX_SRC);</span>

<span class="fc" id="L299">        intentBuilder = PointToPointIntent.builder()</span>
<span class="fc" id="L300">                .appId(appId)</span>
<span class="fc" id="L301">                .key(key)</span>
<span class="fc" id="L302">                .filteredIngressPoint(new FilteredConnectPoint(portOne))</span>
<span class="fc" id="L303">                .filteredEgressPoint(new FilteredConnectPoint(portTwo))</span>
<span class="fc" id="L304">                .selector(selector)</span>
<span class="fc" id="L305">                .treatment(treatmentToPeer.build())</span>
<span class="fc" id="L306">                .priority(PRIORITY_OFFSET);</span>

<span class="fc" id="L308">        encap(intentBuilder, encap);</span>

<span class="fc" id="L310">        intents.add(intentBuilder.build());</span>

        // ICMP path from BGP speaker to BGP peer
<span class="fc" id="L313">        selector = buildSelector(icmpProtocol,</span>
                                 vlanOne,
                                 ipOne,
                                 ipTwo,
                                 null,
                                 null);

<span class="fc" id="L320">        key = buildKey(ipOne, ipTwo, SUFFIX_ICMP);</span>

<span class="fc" id="L322">        intentBuilder = PointToPointIntent.builder()</span>
<span class="fc" id="L323">                            .appId(appId)</span>
<span class="fc" id="L324">                            .key(key)</span>
<span class="fc" id="L325">                            .filteredIngressPoint(new FilteredConnectPoint(portOne))</span>
<span class="fc" id="L326">                            .filteredEgressPoint(new FilteredConnectPoint(portTwo))</span>
<span class="fc" id="L327">                            .selector(selector)</span>
<span class="fc" id="L328">                            .treatment(treatmentToPeer.build())</span>
<span class="fc" id="L329">                            .priority(PRIORITY_OFFSET);</span>

<span class="fc" id="L331">        encap(intentBuilder, encap);</span>

<span class="fc" id="L333">        intents.add(intentBuilder.build());</span>

        // Add VLAN treatment for traffic going from BGP peer to BGP speaker
<span class="fc" id="L336">        treatmentToSpeaker = applyVlanTreatment(vlanTwo, vlanOne, treatmentToSpeaker);</span>

        // Path from BGP peer to BGP speaker matching destination TCP port 179
<span class="fc" id="L339">        selector = buildSelector(tcpProtocol,</span>
                vlanTwo,
                ipTwo,
                ipOne,
                null,
<span class="fc" id="L344">                BGP_PORT);</span>

<span class="fc" id="L346">        key = buildKey(ipTwo, ipOne, SUFFIX_DST);</span>

<span class="fc" id="L348">        intentBuilder = PointToPointIntent.builder()</span>
<span class="fc" id="L349">                .appId(appId)</span>
<span class="fc" id="L350">                .key(key)</span>
<span class="fc" id="L351">                .filteredIngressPoint(new FilteredConnectPoint(portTwo))</span>
<span class="fc" id="L352">                .filteredEgressPoint(new FilteredConnectPoint(portOne))</span>
<span class="fc" id="L353">                .selector(selector)</span>
<span class="fc" id="L354">                .treatment(treatmentToSpeaker.build())</span>
<span class="fc" id="L355">                .priority(PRIORITY_OFFSET);</span>

<span class="fc" id="L357">        encap(intentBuilder, encap);</span>

<span class="fc" id="L359">        intents.add(intentBuilder.build());</span>

        // Path from BGP peer to BGP speaker matching source TCP port 179
<span class="fc" id="L362">        selector = buildSelector(tcpProtocol,</span>
                vlanTwo,
                ipTwo,
                ipOne,
<span class="fc" id="L366">                BGP_PORT,</span>
                null);

<span class="fc" id="L369">        key = buildKey(ipTwo, ipOne, SUFFIX_SRC);</span>

<span class="fc" id="L371">        intentBuilder = PointToPointIntent.builder()</span>
<span class="fc" id="L372">                .appId(appId)</span>
<span class="fc" id="L373">                .key(key)</span>
<span class="fc" id="L374">                .filteredIngressPoint(new FilteredConnectPoint(portTwo))</span>
<span class="fc" id="L375">                .filteredEgressPoint(new FilteredConnectPoint(portOne))</span>
<span class="fc" id="L376">                .selector(selector)</span>
<span class="fc" id="L377">                .treatment(treatmentToSpeaker.build())</span>
<span class="fc" id="L378">                .priority(PRIORITY_OFFSET);</span>

<span class="fc" id="L380">        encap(intentBuilder, encap);</span>

<span class="fc" id="L382">        intents.add(intentBuilder.build());</span>

        // ICMP path from BGP peer to BGP speaker
<span class="fc" id="L385">        selector = buildSelector(icmpProtocol,</span>
                vlanTwo,
                ipTwo,
                ipOne,
                null,
                null);

<span class="fc" id="L392">        key = buildKey(ipTwo, ipOne, SUFFIX_ICMP);</span>

<span class="fc" id="L394">        intentBuilder = PointToPointIntent.builder()</span>
<span class="fc" id="L395">                .appId(appId)</span>
<span class="fc" id="L396">                .key(key)</span>
<span class="fc" id="L397">                .filteredIngressPoint(new FilteredConnectPoint(portTwo))</span>
<span class="fc" id="L398">                .filteredEgressPoint(new FilteredConnectPoint(portOne))</span>
<span class="fc" id="L399">                .selector(selector)</span>
<span class="fc" id="L400">                .treatment(treatmentToSpeaker.build())</span>
<span class="fc" id="L401">                .priority(PRIORITY_OFFSET);</span>

<span class="fc" id="L403">        encap(intentBuilder, encap);</span>

<span class="fc" id="L405">        intents.add(intentBuilder.build());</span>

<span class="fc" id="L407">        return intents;</span>
    }

    /**
     * Builds a traffic selector based on the set of input parameters.
     *
     * @param ipProto IP protocol
     * @param srcIp source IP address
     * @param dstIp destination IP address
     * @param srcTcpPort source TCP port, or null if shouldn't be set
     * @param dstTcpPort destination TCP port, or null if shouldn't be set
     * @return the new traffic selector
     */
    private TrafficSelector buildSelector(byte ipProto, VlanId ingressVlanId,
                                          IpAddress srcIp,
                                          IpAddress dstIp, Short srcTcpPort,
                                          Short dstTcpPort) {
<span class="fc" id="L424">        TrafficSelector.Builder builder = DefaultTrafficSelector.builder().matchIPProtocol(ipProto);</span>

        // Match on VLAN Id if a VLAN Id configured on the ingress interface
<span class="fc bfc" id="L427" title="All 2 branches covered.">        if (!ingressVlanId.equals(VlanId.NONE)) {</span>
<span class="fc" id="L428">            builder.matchVlanId(ingressVlanId);</span>
        }

<span class="pc bpc" id="L431" title="1 of 2 branches missed.">        if (dstIp.isIp4()) {</span>
<span class="fc" id="L432">            builder.matchEthType(Ethernet.TYPE_IPV4)</span>
<span class="fc" id="L433">                   .matchIPSrc(IpPrefix.valueOf(srcIp, IpPrefix.MAX_INET_MASK_LENGTH))</span>
<span class="fc" id="L434">                   .matchIPDst(IpPrefix.valueOf(dstIp, IpPrefix.MAX_INET_MASK_LENGTH));</span>
        } else {
<span class="nc" id="L436">            builder.matchEthType(Ethernet.TYPE_IPV6)</span>
<span class="nc" id="L437">                   .matchIPv6Src(IpPrefix.valueOf(srcIp, IpPrefix.MAX_INET6_MASK_LENGTH))</span>
<span class="nc" id="L438">                   .matchIPv6Dst(IpPrefix.valueOf(dstIp, IpPrefix.MAX_INET6_MASK_LENGTH));</span>
        }

<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (srcTcpPort != null) {</span>
<span class="fc" id="L442">            builder.matchTcpSrc(TpPort.tpPort(srcTcpPort));</span>
        }

<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (dstTcpPort != null) {</span>
<span class="fc" id="L446">            builder.matchTcpDst(TpPort.tpPort(dstTcpPort));</span>
        }

<span class="fc" id="L449">        return builder.build();</span>
    }

    /*
     * Adds the VLAN Id treatment before building the intents, depending on how
     * the VLAN Ids of the BGP speakers and the BGP peers are configured.
     */
    private TrafficTreatment.Builder applyVlanTreatment(VlanId vlanOne,
                                                        VlanId vlanTwo,
                                                        TrafficTreatment.Builder treatment) {
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (!vlanOne.equals(vlanTwo)) {</span>
            // VLANs are different. Do some VLAN treatment
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">            if (vlanTwo.equals(VlanId.NONE)) {</span>
                // VLAN two is none. VLAN one is set. Do a pop
<span class="nc" id="L463">                treatment.popVlan();</span>
            } else {
                // Either both VLANs are set or vlanOne is not
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">                if (vlanOne.equals(VlanId.NONE)) {</span>
                    // VLAN one is none. VLAN two is set. Push the VLAN header
<span class="nc" id="L468">                    treatment.pushVlan();</span>
                }
                // Set the VLAN Id to the egress VLAN Id
<span class="fc" id="L471">                treatment.setVlanId(vlanTwo);</span>
            }
        }
<span class="fc" id="L474">        return treatment;</span>
    }

    /**
     * Builds an intent Key for a point-to-point intent based off the source
     * and destination IP address, as well as a suffix String to distinguish
     * between different types of intents between the same source and
     * destination.
     *
     * @param srcIp source IP address
     * @param dstIp destination IP address
     * @param suffix suffix string
     * @return intent key
     */
    private Key buildKey(IpAddress srcIp, IpAddress dstIp, String suffix) {
<span class="fc" id="L489">        String keyString = new StringBuilder()</span>
<span class="fc" id="L490">                .append(srcIp.toString())</span>
<span class="fc" id="L491">                .append(&quot;-&quot;)</span>
<span class="fc" id="L492">                .append(dstIp.toString())</span>
<span class="fc" id="L493">                .append(&quot;-&quot;)</span>
<span class="fc" id="L494">                .append(suffix)</span>
<span class="fc" id="L495">                .toString();</span>

<span class="fc" id="L497">        return Key.of(keyString, appId);</span>
    }

    /**
     * Adds an encapsulation constraint to the builder given, if encap is not
     * equal to NONE.
     *
     * @param builder the intent builder
     * @param encap the encapsulation type
     */
    private static void encap(ConnectivityIntent.Builder builder,
                              EncapsulationType encap) {
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">        if (!encap.equals(NONE)) {</span>
<span class="nc" id="L510">            builder.constraints(ImmutableList.of(</span>
                    new EncapsulationConstraint(encap)));
        }
<span class="fc" id="L513">    }</span>

<span class="fc" id="L515">    private class InternalNetworkConfigListener implements NetworkConfigListener {</span>

        @Override
        public void event(NetworkConfigEvent event) {
<span class="nc bnc" id="L519" title="All 4 branches missed.">            switch (event.type()) {</span>
            case CONFIG_REGISTERED:
<span class="nc" id="L521">                break;</span>
            case CONFIG_UNREGISTERED:
<span class="nc" id="L523">                break;</span>
            case CONFIG_ADDED:
            case CONFIG_UPDATED:
            case CONFIG_REMOVED:
<span class="nc bnc" id="L527" title="All 2 branches missed.">                if (event.configClass() == RoutingService.CONFIG_CLASS ||</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">                    event.configClass() == SdnIpConfig.class) {</span>
<span class="nc" id="L529">                    setUpConnectivity();</span>
                }
                break;
            default:
                break;
            }
<span class="nc" id="L535">        }</span>
    }

<span class="fc" id="L538">    private class InternalInterfaceListener implements InterfaceListener {</span>
        @Override
        public void event(InterfaceEvent event) {
<span class="nc bnc" id="L541" title="All 2 branches missed.">            switch (event.type()) {</span>
            case INTERFACE_ADDED:
            case INTERFACE_UPDATED:
            case INTERFACE_REMOVED:
<span class="nc" id="L545">                setUpConnectivity();</span>
<span class="nc" id="L546">                break;</span>
            default:
                break;
            }
<span class="nc" id="L550">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>