<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ko"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VplsOperationManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">onos-app-slsnet-vpls</a> &gt; <a href="index.source.html" class="el_package">org.onosproject.vpls</a> &gt; <span class="el_source">VplsOperationManager.java</span></div><h1>VplsOperationManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017-present Open Networking Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.onosproject.vpls;

import com.google.common.collect.Maps;
import com.google.common.collect.Queues;
import com.google.common.collect.Sets;
import org.apache.felix.scr.annotations.Activate;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Deactivate;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.ReferenceCardinality;
import org.apache.felix.scr.annotations.Service;
import org.onlab.util.Tools;
import org.onosproject.cluster.ClusterService;
import org.onosproject.cluster.LeadershipEvent;
import org.onosproject.cluster.LeadershipEventListener;
import org.onosproject.cluster.LeadershipService;
import org.onosproject.cluster.NodeId;
import org.onosproject.core.ApplicationId;
import org.onosproject.core.CoreService;
import org.onosproject.incubator.net.intf.Interface;
import org.onosproject.net.Host;
import org.onosproject.net.host.HostService;
import org.onosproject.net.intent.Intent;
import org.onosproject.net.intent.IntentEvent;
import org.onosproject.net.intent.IntentException;
import org.onosproject.net.intent.IntentListener;
import org.onosproject.net.intent.IntentService;
import org.onosproject.net.intent.IntentUtils;
import org.onosproject.net.intent.Key;
import org.onosproject.net.intent.MultiPointToSinglePointIntent;
import org.onosproject.net.intent.SinglePointToMultiPointIntent;
import org.onosproject.vpls.api.VplsData;
import org.onosproject.vpls.api.VplsOperationException;
import org.onosproject.vpls.api.VplsOperationService;
import org.onosproject.vpls.api.VplsOperation;
import org.onosproject.vpls.api.VplsStore;
import org.onosproject.vpls.intent.VplsIntentUtility;
import org.slf4j.Logger;

import java.util.Collection;
import java.util.Deque;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.onlab.util.BoundedThreadPool.newFixedThreadPool;
import static org.onlab.util.Tools.groupedThreads;
import static org.slf4j.LoggerFactory.getLogger;

/**
 * An implementation of VplsOperationService.
 * Handles the execution order of the VPLS operations generated by the
 * application.
 */
@Component(immediate = true)
@Service
<span class="fc" id="L82">public class VplsOperationManager implements VplsOperationService {</span>
    private static final int NUM_THREADS = 4;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected CoreService coreService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected IntentService intentService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected LeadershipService leadershipService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected ClusterService clusterService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected HostService hostService;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected VplsStore vplsStore;

<span class="fc" id="L103">    private final Logger log = getLogger(getClass());</span>
    protected Map&lt;String, Deque&lt;VplsOperation&gt;&gt; pendingVplsOperations;
<span class="fc" id="L105">    protected final Map&lt;String, VplsOperation&gt; runningOperations = Maps.newHashMap();</span>
    protected ScheduledExecutorService schedulerExecutor;
    protected ExecutorService workerExecutor;
    protected ApplicationId appId;
    protected boolean isLeader;
    protected NodeId localNodeId;
    protected LeadershipEventListener leadershipEventListener;

    @Activate
    public void activate() {
<span class="fc" id="L115">        appId = coreService.registerApplication(VplsManager.VPLS_APP);</span>
<span class="fc" id="L116">        localNodeId = clusterService.getLocalNode().id();</span>

<span class="fc" id="L118">        leadershipEventListener = new InternalLeadershipListener();</span>
<span class="fc" id="L119">        leadershipService.addListener(leadershipEventListener);</span>
<span class="fc" id="L120">        leadershipService.runForLeadership(appId.name());</span>
<span class="fc" id="L121">        pendingVplsOperations = Maps.newConcurrentMap();</span>

        // Thread pool for VplsOperationExecutor
<span class="fc" id="L124">        workerExecutor = newFixedThreadPool(NUM_THREADS,</span>
<span class="fc" id="L125">                                            groupedThreads(&quot;onos/apps/vpls&quot;,</span>
                                                           &quot;worker-%d&quot;,
                                                           log));
        // A single thread pool for VplsOperationScheduler
<span class="fc" id="L129">        schedulerExecutor = Executors.newScheduledThreadPool(1,</span>
<span class="fc" id="L130">                                                             groupedThreads(&quot;onos/apps/vpls&quot;,</span>
                                                                            &quot;scheduler-%d&quot;,
                                                                            log));
        // Start the scheduler
<span class="fc" id="L134">        schedulerExecutor.scheduleAtFixedRate(new VplsOperationScheduler(),</span>
                                              0,
                                              500,
                                              TimeUnit.MILLISECONDS);

<span class="fc" id="L139">    }</span>

    @Deactivate
    public void deactivate() {
<span class="fc" id="L143">        pendingVplsOperations.clear();</span>
<span class="fc" id="L144">        runningOperations.clear();</span>
<span class="fc" id="L145">        leadershipService.removeListener(leadershipEventListener);</span>
<span class="fc" id="L146">        schedulerExecutor.shutdown();</span>
<span class="fc" id="L147">        workerExecutor.shutdown();</span>

        // remove all intents from VPLS application when deactivated
<span class="fc" id="L150">        Tools.stream(intentService.getIntents())</span>
<span class="fc" id="L151">                .filter(intent -&gt; intent.appId().equals(appId))</span>
<span class="fc" id="L152">                .forEach(intentService::withdraw);</span>
<span class="fc" id="L153">    }</span>

    @Override
    public void submit(VplsOperation vplsOperation) {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (isLeader) {</span>
            // Only leader can execute operation
<span class="fc" id="L159">            addVplsOperation(vplsOperation);</span>
        }
<span class="fc" id="L161">    }</span>

    /**
     * Adds a VPLS operation to the queue of pending operations.
     *
     * @param vplsOperation the VPLS operation to add
     */
    private void addVplsOperation(VplsOperation vplsOperation) {
<span class="fc" id="L169">        VplsData vplsData = vplsOperation.vpls();</span>
<span class="fc" id="L170">        pendingVplsOperations.compute(vplsData.name(), (name, opQueue) -&gt; {</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">            opQueue = opQueue == null ? Queues.newArrayDeque() : opQueue;</span>

            // If the operation already exist in queue, ignore it.
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (opQueue.contains(vplsOperation)) {</span>
<span class="fc" id="L175">                return opQueue;</span>
            }
<span class="fc" id="L177">            opQueue.add(vplsOperation);</span>
<span class="fc" id="L178">            return opQueue;</span>
        });
<span class="fc" id="L180">    }</span>

    /**
     * Optimizes the VPLS operation queue and return a single VPLS operation to
     * execute.
     *
     * @param operations the queue to be optimized
     * @return optimized VPLS operation from the queue
     */
    protected static VplsOperation getOptimizedVplsOperation(Deque&lt;VplsOperation&gt; operations) {
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (operations.isEmpty()) {</span>
<span class="fc" id="L191">            return null;</span>
        }
        // no need to optimize if the queue contains only one operation
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (operations.size() == 1) {</span>
<span class="fc" id="L195">            return operations.getFirst();</span>
        }

<span class="fc" id="L198">        final VplsOperation firstOperation = operations.peekFirst();</span>
<span class="fc" id="L199">        final VplsOperation lastOperation = operations.peekLast();</span>
<span class="fc" id="L200">        final VplsOperation.Operation firstOp = firstOperation.op();</span>
<span class="fc" id="L201">        final VplsOperation.Operation lastOp = lastOperation.op();</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (firstOp.equals(VplsOperation.Operation.REMOVE)) {</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if (lastOp.equals(VplsOperation.Operation.REMOVE)) {</span>
                // case 1: both first and last operation are REMOVE; do remove
<span class="fc" id="L206">                return firstOperation;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            } else if (lastOp.equals(VplsOperation.Operation.ADD)) {</span>
                // case 2: if first is REMOVE, and last is ADD; do update
<span class="fc" id="L209">                return VplsOperation.of(lastOperation.vpls(),</span>
                                                 VplsOperation.Operation.UPDATE);
            } else {
                // case 3: first is REMOVE, last is UPDATE; do update
<span class="fc" id="L213">                return lastOperation;</span>
            }
<span class="fc bfc" id="L215" title="All 2 branches covered.">        } else if (firstOp.equals(VplsOperation.Operation.ADD)) {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">            if (lastOp.equals(VplsOperation.Operation.REMOVE)) {</span>
                // case 4: first is ADD, last is REMOVE; nothing to do
<span class="fc" id="L218">                return null;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">            } else if (lastOp.equals(VplsOperation.Operation.ADD)) {</span>
                // case 5: both first and last are ADD, do add
<span class="fc" id="L221">                return VplsOperation.of(lastOperation.vpls(),</span>
                                                 VplsOperation.Operation.ADD);
            } else {
                // case 6: first is ADD and last is update, do add
<span class="fc" id="L225">                return VplsOperation.of(lastOperation.vpls(),</span>
                                                 VplsOperation.Operation.ADD);
            }
        } else {
<span class="fc bfc" id="L229" title="All 2 branches covered.">            if (lastOp.equals(VplsOperation.Operation.REMOVE)) {</span>
                // case 7: last is remove, do remove
<span class="fc" id="L231">                return lastOperation;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">            } else if (lastOp.equals(VplsOperation.Operation.ADD)) {</span>
                // case 8: do update only
<span class="fc" id="L234">                return VplsOperation.of(lastOperation.vpls(),</span>
                                                 VplsOperation.Operation.UPDATE);
            } else {
                // case 9: from UPDATE to UPDATE
                // only need last UPDATE operation
<span class="fc" id="L239">                return VplsOperation.of(lastOperation.vpls(),</span>
                                                 VplsOperation.Operation.UPDATE);
            }
        }
    }

    /**
     * Scheduler for VPLS operation.
     * Processes a batch of VPLS operations in a period.
     */
<span class="fc" id="L249">    class VplsOperationScheduler implements Runnable {</span>
        private static final String UNKNOWN_STATE =
                &quot;Unknown state {} for success consumer&quot;;
        private static final String OP_EXEC_ERR =
                &quot;Error when executing VPLS operation {}, error: {}&quot;;

        /**
         * Process a batch of VPLS operations.
         */
        @Override
        public void run() {
<span class="fc" id="L260">            Set&lt;String&gt; vplsNames = pendingVplsOperations.keySet();</span>
<span class="fc" id="L261">            vplsNames.forEach(vplsName -&gt; {</span>
                VplsOperation operation;
<span class="fc" id="L263">                synchronized (runningOperations) {</span>
                    // Only one operation for a VPLS at the same time
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">                    if (runningOperations.containsKey(vplsName)) {</span>
<span class="nc" id="L266">                        return;</span>
                    }
<span class="fc" id="L268">                    Deque&lt;VplsOperation&gt; operations = pendingVplsOperations.remove(vplsName);</span>
<span class="fc" id="L269">                    operation = getOptimizedVplsOperation(operations);</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">                    if (operation == null) {</span>
                        // Nothing to do, this only happened when we add a VPLS
                        // and remove it before batch operations been processed.
<span class="fc" id="L273">                        return;</span>
                    }
<span class="fc" id="L275">                    runningOperations.put(vplsName, operation);</span>
<span class="pc" id="L276">                }</span>

<span class="fc" id="L278">                VplsOperationExecutor operationExecutor =</span>
                        new VplsOperationExecutor(operation);
<span class="fc" id="L280">                operationExecutor.setConsumers(</span>
                        (vplsOperation) -&gt; {
                            // Success consumer
<span class="fc" id="L283">                            VplsData vplsData = vplsOperation.vpls();</span>
<span class="fc" id="L284">                            log.debug(&quot;VPLS operation success: {}&quot;, vplsOperation);</span>
<span class="pc bpc" id="L285" title="1 of 3 branches missed.">                            switch (vplsData.state()) {</span>
                                case ADDING:
                                case UPDATING:
<span class="fc" id="L288">                                    vplsData.state(VplsData.VplsState.ADDED);</span>
<span class="fc" id="L289">                                    vplsStore.updateVpls(vplsData);</span>
<span class="fc" id="L290">                                    break;</span>
                                case REMOVING:
                                    // The VPLS information does not exists in
                                    // store. No need to update the store.
<span class="fc" id="L294">                                    break;</span>
                                default:
<span class="nc" id="L296">                                    log.warn(UNKNOWN_STATE, vplsData.state());</span>
<span class="nc" id="L297">                                    vplsData.state(VplsData.VplsState.FAILED);</span>
<span class="nc" id="L298">                                    vplsStore.updateVpls(vplsData);</span>
                                    break;
                            }
<span class="fc" id="L301">                            runningOperations.remove(vplsName);</span>
<span class="fc" id="L302">                        },</span>
                        (vplsOperationException) -&gt; {
                            // Error consumer
<span class="fc" id="L305">                            VplsOperation vplsOperation =</span>
<span class="fc" id="L306">                                    vplsOperationException.vplsOperation();</span>
<span class="fc" id="L307">                            log.warn(OP_EXEC_ERR,</span>
<span class="fc" id="L308">                                     vplsOperation.toString(),</span>
<span class="fc" id="L309">                                     vplsOperationException.getMessage());</span>
<span class="fc" id="L310">                            VplsData vplsData = vplsOperation.vpls();</span>
<span class="fc" id="L311">                            vplsData.state(VplsData.VplsState.FAILED);</span>
<span class="fc" id="L312">                            vplsStore.updateVpls(vplsData);</span>
<span class="fc" id="L313">                            runningOperations.remove(vplsName);</span>
<span class="fc" id="L314">                        });</span>
<span class="fc" id="L315">                log.debug(&quot;Applying operation: {}&quot;, operation);</span>
<span class="fc" id="L316">                workerExecutor.execute(operationExecutor);</span>
<span class="fc" id="L317">            });</span>
<span class="fc" id="L318">        }</span>
    }

    /**
     * Direction for Intent installation.
     */
<span class="pc" id="L324">    private enum Direction {</span>
<span class="fc" id="L325">        ADD,</span>
<span class="fc" id="L326">        REMOVE</span>
    }

    /**
     * VPLS operation executor.
     * Installs, updates or removes Intents according to the given VPLS operation.
     */
    class VplsOperationExecutor implements Runnable {
        private static final String UNKNOWN_OP = &quot;Unknown operation.&quot;;
        private static final String UNKNOWN_INTENT_DIR = &quot;Unknown Intent install direction.&quot;;
        private static final int OPERATION_TIMEOUT = 10;
        private VplsOperation vplsOperation;
        private Consumer&lt;VplsOperation&gt; successConsumer;
        private Consumer&lt;VplsOperationException&gt; errorConsumer;
        private VplsOperationException error;

<span class="fc" id="L342">        public VplsOperationExecutor(VplsOperation vplsOperation) {</span>
<span class="fc" id="L343">            this.vplsOperation = vplsOperation;</span>
<span class="fc" id="L344">            this.error = null;</span>
<span class="fc" id="L345">        }</span>

        /**
         * Sets success consumer and error consumer for this executor.
         *
         * @param successConsumer the success consumer
         * @param errorConsumer the error consumer
         */
        public void setConsumers(Consumer&lt;VplsOperation&gt; successConsumer,
                                 Consumer&lt;VplsOperationException&gt; errorConsumer) {
<span class="fc" id="L355">            this.successConsumer = successConsumer;</span>
<span class="fc" id="L356">            this.errorConsumer = errorConsumer;</span>

<span class="fc" id="L358">        }</span>

        @Override
        public void run() {
<span class="pc bpc" id="L362" title="1 of 4 branches missed.">            switch (vplsOperation.op()) {</span>
                case ADD:
<span class="fc" id="L364">                    installVplsIntents();</span>
<span class="fc" id="L365">                    break;</span>
                case REMOVE:
<span class="fc" id="L367">                    removeVplsIntents();</span>
<span class="fc" id="L368">                    break;</span>
                case UPDATE:
<span class="fc" id="L370">                    updateVplsIntents();</span>
<span class="fc" id="L371">                    break;</span>
                default:
<span class="nc" id="L373">                    this.error = new VplsOperationException(vplsOperation,</span>
                                                            UNKNOWN_OP);
                    break;
            }

<span class="fc bfc" id="L378" title="All 2 branches covered.">            if (this.error != null) {</span>
<span class="fc" id="L379">                errorConsumer.accept(this.error);</span>
            } else {
<span class="fc" id="L381">                successConsumer.accept(vplsOperation);</span>
            }
<span class="fc" id="L383">        }</span>

        /**
         * Updates Intents of the VPLS.
         */
        private void updateVplsIntents() {
            // check which part we need to update
            // if we update host only, we don't need to reinstall
            // every Intents
<span class="fc" id="L392">            Set&lt;Intent&gt; intentsToInstall = Sets.newHashSet();</span>
<span class="fc" id="L393">            Set&lt;Intent&gt; intentsToUninstall = Sets.newHashSet();</span>
<span class="fc" id="L394">            VplsData vplsData = vplsOperation.vpls();</span>
<span class="fc" id="L395">            Set&lt;Intent&gt; currentIntents = getCurrentIntents();</span>

            // Compares broadcast Intents
<span class="fc" id="L398">            Set&lt;Intent&gt; currentBrcIntents = currentIntents.stream()</span>
<span class="fc" id="L399">                    .filter(intent -&gt; intent instanceof SinglePointToMultiPointIntent)</span>
<span class="fc" id="L400">                    .collect(Collectors.toSet());</span>
<span class="fc" id="L401">            Set&lt;Intent&gt; targetBrcIntents = VplsIntentUtility.buildBrcIntents(vplsData, appId);</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">            if (!intentSetEquals(currentBrcIntents, targetBrcIntents)) {</span>
                // If broadcast Intents changes, it means some network
                // interfaces or encapsulation constraint changed; Need to
                // reinstall all intents
<span class="fc" id="L406">                removeVplsIntents();</span>
<span class="fc" id="L407">                installVplsIntents();</span>
<span class="fc" id="L408">                return;</span>
            }

            // Compares unicast Intents
<span class="fc" id="L412">            Set&lt;Intent&gt; currentUniIntents = currentIntents.stream()</span>
<span class="fc" id="L413">                    .filter(intent -&gt; intent instanceof MultiPointToSinglePointIntent)</span>
<span class="fc" id="L414">                    .collect(Collectors.toSet());</span>
<span class="fc" id="L415">            Set&lt;Intent&gt; targetUniIntents = VplsIntentUtility.buildUniIntents(vplsData,</span>
<span class="fc" id="L416">                                                                             hostsFromVpls(),</span>
                                                                             appId);

            // New unicast Intents to install
<span class="fc" id="L420">            targetUniIntents.forEach(intent -&gt; {</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">                if (!currentUniIntents.contains(intent)) {</span>
<span class="fc" id="L422">                    intentsToInstall.add(intent);</span>
                }
<span class="fc" id="L424">            });</span>

            // Old unicast Intents to remove
<span class="fc" id="L427">            currentUniIntents.forEach(intent -&gt; {</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                if (!targetUniIntents.contains(intent)) {</span>
<span class="nc" id="L429">                    intentsToUninstall.add(intent);</span>
                }
<span class="nc" id="L431">            });</span>
<span class="fc" id="L432">            applyIntentsSync(intentsToUninstall, Direction.REMOVE);</span>
<span class="fc" id="L433">            applyIntentsSync(intentsToInstall, Direction.ADD);</span>
<span class="fc" id="L434">        }</span>

        private Set&lt;Host&gt; hostsFromVpls() {
<span class="fc" id="L437">            VplsData vplsData = vplsOperation.vpls();</span>
<span class="fc" id="L438">            Set&lt;Interface&gt; interfaces = vplsData.interfaces();</span>
<span class="fc" id="L439">            return interfaces.stream()</span>
<span class="fc" id="L440">                    .map(this::hostsFromInterface)</span>
<span class="fc" id="L441">                    .flatMap(Collection::stream)</span>
<span class="fc" id="L442">                    .collect(Collectors.toSet());</span>
        }

        private Set&lt;Host&gt; hostsFromInterface(Interface iface) {
<span class="fc" id="L446">            return hostService.getConnectedHosts(iface.connectPoint())</span>
<span class="fc" id="L447">                    .stream()</span>
<span class="fc" id="L448">                    .filter(host -&gt; host.vlan().equals(iface.vlan()))</span>
<span class="fc" id="L449">                    .collect(Collectors.toSet());</span>
        }

        /**
         * Applies Intents synchronously with a specific direction.
         *
         * @param intents the Intents
         * @param direction the direction
         */
        private void applyIntentsSync(Set&lt;Intent&gt; intents, Direction direction) {
<span class="fc" id="L459">            Set&lt;Key&gt; pendingIntentKeys = intents.stream()</span>
<span class="fc" id="L460">                    .map(Intent::key).collect(Collectors.toSet());</span>
            IntentCompleter completer;

<span class="pc bpc" id="L463" title="1 of 3 branches missed.">            switch (direction) {</span>
                case ADD:
<span class="fc" id="L465">                    completer = new IntentCompleter(pendingIntentKeys,</span>
                                                    IntentEvent.Type.INSTALLED);
<span class="fc" id="L467">                    intentService.addListener(completer);</span>
<span class="fc" id="L468">                    intents.forEach(intentService::submit);</span>
<span class="fc" id="L469">                    break;</span>
                case REMOVE:
<span class="fc" id="L471">                    completer = new IntentCompleter(pendingIntentKeys,</span>
                                                    IntentEvent.Type.WITHDRAWN);
<span class="fc" id="L473">                    intentService.addListener(completer);</span>
<span class="fc" id="L474">                    intents.forEach(intentService::withdraw);</span>
<span class="fc" id="L475">                    break;</span>
                default:
<span class="nc" id="L477">                    this.error = new VplsOperationException(this.vplsOperation,</span>
                                                            UNKNOWN_INTENT_DIR);
<span class="nc" id="L479">                    return;</span>
            }

            try {
                // Wait until Intent operation completed
<span class="fc" id="L484">                completer.complete();</span>
<span class="fc" id="L485">            } catch (VplsOperationException e) {</span>
<span class="fc" id="L486">                this.error = e;</span>
            } finally {
<span class="pc" id="L488">                intentService.removeListener(completer);</span>
<span class="fc" id="L489">            }</span>
<span class="fc" id="L490">        }</span>

        /**
         * Checks if two sets of Intents are equal.
         *
         * @param intentSet1 the first set of Intents
         * @param intentSet2 the second set of Intents
         * @return true if both set of Intents are equal; otherwise false
         */
        private boolean intentSetEquals(Set&lt;Intent&gt; intentSet1, Set&lt;Intent&gt; intentSet2) {
<span class="fc bfc" id="L500" title="All 2 branches covered.">            if (intentSet1.size() != intentSet2.size()) {</span>
<span class="fc" id="L501">                return false;</span>
            }
<span class="fc bfc" id="L503" title="All 2 branches covered.">            for (Intent intent1 : intentSet1) {</span>
<span class="fc" id="L504">                if (intentSet2.stream()</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">                        .noneMatch(intent2 -&gt; IntentUtils.intentsAreEqual(intent1, intent2))) {</span>
<span class="nc" id="L506">                    return false;</span>
                }
<span class="fc" id="L508">            }</span>
<span class="fc" id="L509">            return true;</span>
        }

        /**
         * Retrieves installed Intents from IntentService which related to
         * specific VPLS.
         *
         * @return the Intents which related to the VPLS
         */
        private Set&lt;Intent&gt; getCurrentIntents() {
<span class="fc" id="L519">            VplsData vplsData = vplsOperation.vpls();</span>
<span class="fc" id="L520">            String vplsName = vplsData.name();</span>
<span class="fc" id="L521">            return Tools.stream(intentService.getIntents())</span>
<span class="fc" id="L522">                    .filter(intent -&gt; intent.key().toString().startsWith(vplsName))</span>
<span class="fc" id="L523">                    .collect(Collectors.toSet());</span>
        }

        /**
         * Generates unicast Intents and broadcast Intents for the VPLS.
         *
         * @return Intents for the VPLS
         */
        private Set&lt;Intent&gt; generateVplsIntents() {
<span class="fc" id="L532">            VplsData vplsData = vplsOperation.vpls();</span>
<span class="fc" id="L533">            Set&lt;Intent&gt; brcIntents = VplsIntentUtility.buildBrcIntents(vplsData, appId);</span>
<span class="fc" id="L534">            Set&lt;Intent&gt; uniIntent = VplsIntentUtility.buildUniIntents(vplsData, hostsFromVpls(), appId);</span>

<span class="fc" id="L536">            return Stream.concat(brcIntents.stream(), uniIntent.stream())</span>
<span class="fc" id="L537">                    .collect(Collectors.toSet());</span>
        }

        /**
         * Removes all Intents from the VPLS.
         */
        private void removeVplsIntents() {
<span class="fc" id="L544">            Set&lt;Intent&gt; intentsToWithdraw = getCurrentIntents();</span>
<span class="fc" id="L545">            applyIntentsSync(intentsToWithdraw, Direction.REMOVE);</span>
<span class="fc" id="L546">            intentsToWithdraw.forEach(intentService::purge);</span>
<span class="fc" id="L547">        }</span>

        /**
         * Installs Intents of the VPLS.
         */
        private void installVplsIntents() {
<span class="fc" id="L553">            Set&lt;Intent&gt; intentsToInstall = generateVplsIntents();</span>
<span class="fc" id="L554">            applyIntentsSync(intentsToInstall, Direction.ADD);</span>
<span class="fc" id="L555">        }</span>

        /**
         * Helper class which monitors if all Intent operations are completed.
         */
        class IntentCompleter implements IntentListener {
            private static final String INTENT_COMPILE_ERR = &quot;Got {} from intent completer&quot;;
            private CompletableFuture&lt;Void&gt; completableFuture;
            private Set&lt;Key&gt; pendingIntentKeys;
            private IntentEvent.Type expectedEventType;

            /**
             * Initialize completer with given Intent keys and expect Intent
             * event type.
             *
             * @param pendingIntentKeys the Intent keys to wait
             * @param expectedEventType expect Intent event type
             */
            public IntentCompleter(Set&lt;Key&gt; pendingIntentKeys,
<span class="fc" id="L574">                                   IntentEvent.Type expectedEventType) {</span>
<span class="fc" id="L575">                this.completableFuture = new CompletableFuture&lt;&gt;();</span>
<span class="fc" id="L576">                this.pendingIntentKeys = Sets.newConcurrentHashSet(pendingIntentKeys);</span>
<span class="fc" id="L577">                this.expectedEventType = expectedEventType;</span>
<span class="fc" id="L578">            }</span>

            @Override
            public void event(IntentEvent event) {
<span class="fc" id="L582">                Intent intent = event.subject();</span>
<span class="fc" id="L583">                Key key = intent.key();</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">                if (!pendingIntentKeys.contains(key)) {</span>
                    // ignore Intent events from other VPLS
<span class="nc" id="L586">                    return;</span>
                }
                // Intent failed, throw an exception to completable future
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">                if (event.type() == IntentEvent.Type.CORRUPT ||</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">                        event.type() == IntentEvent.Type.FAILED) {</span>
<span class="fc" id="L591">                    completableFuture.completeExceptionally(new IntentException(intent.toString()));</span>
<span class="fc" id="L592">                    return;</span>
                }
                // If event type matched to expected type, remove from pending
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">                if (event.type() == expectedEventType) {</span>
<span class="fc" id="L596">                    pendingIntentKeys.remove(key);</span>
                }
<span class="fc bfc" id="L598" title="All 2 branches covered.">                if (pendingIntentKeys.isEmpty()) {</span>
<span class="fc" id="L599">                    completableFuture.complete(null);</span>
                }
<span class="fc" id="L601">            }</span>

            /**
             * Waits until all pending Intents completed ot timeout.
             */
            public void complete() {
                // If no pending Intent keys, complete directly
<span class="fc bfc" id="L608" title="All 2 branches covered.">                if (pendingIntentKeys.isEmpty()) {</span>
<span class="fc" id="L609">                    return;</span>
                }
                try {
<span class="nc" id="L612">                    completableFuture.get(OPERATION_TIMEOUT, TimeUnit.SECONDS);</span>
<span class="fc" id="L613">                } catch (TimeoutException | InterruptedException |</span>
                         ExecutionException | IntentException e) {
                    // TODO: handle errors more carefully
<span class="fc" id="L616">                    log.warn(INTENT_COMPILE_ERR, e.toString());</span>
<span class="fc" id="L617">                    throw new VplsOperationException(vplsOperation, e.toString());</span>
<span class="nc" id="L618">                }</span>
<span class="nc" id="L619">            }</span>
        }
    }

    /**
     * A listener for leadership events.
     * Only the leader can process VPLS operation in the ONOS cluster.
     */
<span class="fc" id="L627">    private class InternalLeadershipListener implements LeadershipEventListener {</span>
        private static final String LEADER_CHANGE = &quot;Change leader to {}&quot;;

        @Override
        public void event(LeadershipEvent event) {
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">            switch (event.type()) {</span>
                case LEADER_CHANGED:
                case LEADER_AND_CANDIDATES_CHANGED:
<span class="fc" id="L635">                    isLeader = localNodeId.equals(event.subject().leaderNodeId());</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">                    if (isLeader) {</span>
<span class="fc" id="L637">                        log.debug(LEADER_CHANGE, localNodeId);</span>
                    }
                    break;
                default:
                    break;
            }
<span class="fc" id="L643">        }</span>

        @Override
        public boolean isRelevant(LeadershipEvent event) {
<span class="fc" id="L647">            return event.subject().topic().equals(appId.name());</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>